package com._8x8.cloud.hss.resource;

import org.apache.commons.codec.digest.DigestUtils;
import org.apache.commons.io.FileUtils;
import org.apache.commons.io.IOUtils;
import org.glassfish.jersey.internal.util.Base64;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.springframework.test.context.ContextConfiguration;
import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;

import javax.annotation.Resource;
import javax.ws.rs.client.ClientBuilder;
import javax.ws.rs.client.Entity;
import javax.ws.rs.client.WebTarget;
import javax.ws.rs.core.MediaType;
import javax.ws.rs.core.Response;
import javax.ws.rs.core.UriInfo;
import java.io.File;
import java.io.InputStream;
import java.util.List;
import java.util.UUID;

import static org.hamcrest.Matchers.equalTo;
import static org.hamcrest.Matchers.greaterThan;
import static org.hamcrest.Matchers.not;
import static org.hamcrest.Matchers.nullValue;
import static org.hamcrest.core.Is.is;

/**
 * Tests the {@link StreamResource} at the integration level. Please note that you must be running HSS in a servlet
 * container to run this test.
 *
 * @author kog@epiphanic.org
 * @since 05/28/2015
 */
@RunWith(SpringJUnit4ClassRunner.class)
@ContextConfiguration("classpath*:applicationContext.xml")
public class StreamResourceITCase
{
    /**
     * Holds the "prefix" to all our URLs - this is pointing to our localhost Streams resource.
     */
    private static final String URL_PREFIX = "http://localhost:8080/hss/api/streams";

    /**
     * Holds a {@link WebTarget} pointing at our base resource.
     */
    private WebTarget _client = ClientBuilder.newClient().target(URL_PREFIX);

    /**
     * Holds a unique ID, generated by {@link #setUp()}.
     */
    private String _uuid;

    /**
     * Holds a test payload, generated by {@link #setUp()}.
     */
    private String _testPayload;

    // TODO [kog@epiphanic.org - 5/30/15]: Should override the production config, and make /tmp + uuid.

    /**
     * Holds the directory we're using to store our files. We're going to want to do some secondary verification.
     */
    @Resource
    private String _storageDirectory;

    @Before
    public void setUp() throws Exception
    {
        _uuid = UUID.randomUUID().toString();
        _testPayload = String.format("%s Body payload etc etc", _uuid);
    }

    /**
     * Tests {@link StreamResource#getStreamById(String, List)} for the happy path. We should get a 200/OK with our input
     * stream.
     */
    @Test
    public void testGetStreamById() throws Exception
    {
        // We're going to cheat and write the file straight to the filesystem.
        final File file = new File(_storageDirectory, _uuid);
        FileUtils.write(file, _testPayload);

        // So... this should already be here.
        final Response response = _client.path(_uuid).request("application/octet-stream").get();

        // We should get a 200/OK with what we wrote to the filesystem earlier.
        Assert.assertThat(200, is(equalTo(response.getStatus())));
        Assert.assertThat(response.readEntity(String.class), is(equalTo(_testPayload)));

        // Clean up after ourselves. Hopefully.
        FileUtils.deleteQuietly(file);
    }

    /**
     * Tests {@link StreamResource#getStreamById(String, List)} for the case where the ID is not know to the system. We should
     * get a 404/NOT FOUND here.
     */
    @Test
    public void testGetStreamByIdNotKnown() throws Exception
    {
        // Verify nothing is on the filesystem with that ID.
        Assert.assertThat(false, is(equalTo(new File(_storageDirectory, _uuid).exists())));

        final Response response = _client.path(_uuid).request("application/octet-stream").get();

        // We should get a 404/NOT FOUND here.
        Assert.assertThat(404, is(equalTo(response.getStatus())));
    }

    /**
     * Tests {@link StreamResource#getStreamById(String, List)} for the case where the ID of the stream is considered invalid.
     * This should return a 403/FORBIDDEN.
     */
    @Test
    public void testGetStreamByIdForInvalidId() throws Exception
    {
        final Response response = _client.path("/IAmAnInvalidP@th").request("application/octet-stream").get();

        // This should be a 403/FORBIDDEN.
        Assert.assertThat(403, is(equalTo(response.getStatus())));
    }

    /**
     * Tests {@link StreamResource#createStream(UriInfo, String, List, InputStream)} for the happy path. We should get a
     * 201/CREATED with a location header to the new resource.
     */
    @Test
    public void testCreateStream() throws Exception
    {
        // Verify nothing is on the filesystem with that ID.
        final File file = new File(_storageDirectory, _uuid);
        Assert.assertThat(false, is(equalTo(file.exists())));

        // Let's post that bad boy as app/octet-stream.
        final InputStream fauxFile = IOUtils.toInputStream(_testPayload);
        final Response response = _client.path(String.format("/%s", _uuid)).request().post(Entity.entity(fauxFile, MediaType.APPLICATION_OCTET_STREAM_TYPE));

        // We should get back a 201/CREATED with a Location header to /(uuid).
        final String location = response.getLocation().toASCIIString();
        Assert.assertThat(201, is(equalTo(response.getStatus())));
        Assert.assertThat(URL_PREFIX + "/" + _uuid, is(equalTo(location)));

        // And if we hit that resource, we should get our file back.
        final WebTarget newClient = ClientBuilder.newClient().target(location);
        final Response getResponse = newClient.request("application/octet-stream").get();

        // We should get a 200/OK with what we wrote to the filesystem earlier.
        Assert.assertThat(200, is(equalTo(getResponse.getStatus())));
        Assert.assertThat(getResponse.readEntity(String.class), is(equalTo(_testPayload)));

        // Clean up after ourselves. Hopefully.
        FileUtils.deleteQuietly(file);
    }

    /**
     * Tests {@link StreamResource#createStream(UriInfo, String, List, InputStream)} for the case where we're trying to create
     * a stream for an ID that already exists. We should get a 409/CONFLICT back here.
     */
    @Test
    public void testCreateStreamThatAlreadyExists() throws Exception
    {
        // We're going to cheat and write the file straight to the filesystem.
        final File file = new File(_storageDirectory, _uuid);
        FileUtils.write(file, _testPayload);

        // Let's post that bad boy as app/octet-stream.
        final InputStream fauxFile = IOUtils.toInputStream(_testPayload);
        final Response response = _client.path(String.format("/%s", _uuid)).request().post(Entity.entity(fauxFile, MediaType.APPLICATION_OCTET_STREAM_TYPE));

        // We should get back a 409/CONFLICT since this already exists. Obviously there should be no location header here.
        Assert.assertThat(409, is(equalTo(response.getStatus())));
        Assert.assertThat(response.getLocation(), is(nullValue()));

        // Clean up after ourselves. Hopefully.
        FileUtils.deleteQuietly(file);
    }

    /**
     * Tests {@link StreamResource#createStream(UriInfo, String, List, InputStream)} for the case where we're trying to create
     * a stream for an invalid ID. We should get a 403/FORBIDDEN here.
     */
    @Test
    public void testCreateStreamForInvalidId() throws Exception
    {
        // Let's create an invalid stream name.
        final String id = "@-"+ _uuid;

        // Let's post that bad boy as app/octet-stream.
        final InputStream fauxFile = IOUtils.toInputStream(_testPayload);
        final Response response = _client.path(String.format("/%s", id)).request().post(Entity.entity(fauxFile, MediaType.APPLICATION_OCTET_STREAM_TYPE));

        // No @ allowed in the path: we should get a 403/FORBIDDEN and no location header.
        Assert.assertThat(403, is(equalTo(response.getStatus())));
        Assert.assertThat(response.getLocation(), is(nullValue()));
    }

    /**
     * Tests {@link StreamResource#updateStream(String, List, InputStream)} for the happy path. We should get a 204/NO CONTENT
     * back.
     */
    @Test
    public void testUpdateStream() throws Exception
    {
        // We're going to cheat and write the file straight to the filesystem.
        final File file = new File(_storageDirectory, _uuid);
        FileUtils.write(file, _testPayload);

        final String updatedPayload = UUID.randomUUID().toString() + " I AM TOTALLY UPDATED";

        // Let's put that bad boy as app/octet-stream.
        final InputStream fauxFile = IOUtils.toInputStream(updatedPayload);
        final Response response = _client.path(String.format("/%s", _uuid)).request().put(Entity.entity(fauxFile, MediaType.APPLICATION_OCTET_STREAM_TYPE));

        // We should get a 204/NO CONTENT back. And there should be no content.
        Assert.assertThat(204, is(equalTo(response.getStatus())));
        Assert.assertThat(response.readEntity(Object.class), is(nullValue()));

        // The Jersey Client is actually going to represent this value as -1 instead of 0. The former is invalid per RFC-2616.
        Assert.assertThat(1, greaterThan(response.getLength()));

        // Just to be sure...
        Assert.assertThat(1, is(equalTo(response.getHeaders().size())));
        Assert.assertThat("Content-Length", not(equalTo(response.getHeaders().values().iterator().next())));

        // And now make sure what's on our filesystem matches what we thought we updated to.
        Assert.assertThat(updatedPayload, is(equalTo(FileUtils.readFileToString(file))));

        // Clean up after ourselves. Hopefully.
        FileUtils.deleteQuietly(file);
    }

    /**
     * Tests {@link StreamResource#updateStream(String, List, InputStream)} for the case where we're trying to update an ID
     * that doesn't already exist. This should return a 404/NOT FOUND.
     */
    @Test
    public void testUpdateStreamThatDoesNotExist() throws Exception
    {
        // Verify nothing is on the filesystem with that ID.
        final File file = new File(_storageDirectory, _uuid);
        Assert.assertThat(false, is(equalTo(file.exists())));

        // Let's put that bad boy as app/octet-stream.
        final InputStream fauxFile = IOUtils.toInputStream(_testPayload);
        final Response response = _client.path(String.format("/%s", _uuid)).request().put(Entity.entity(fauxFile, MediaType.APPLICATION_OCTET_STREAM_TYPE));

        // Can't update something that does not exist.
        Assert.assertThat(404, is(equalTo(response.getStatus())));
    }
    
    /**
     * Tests {@link StreamResource#updateStream(String, List, InputStream)} for the case where we're trying an invalid ID. We
     * should get a 403/FORBIDDEN back.
     */
    @Test
    public void testUpdateStreamForInvalidId() throws Exception
    {
        // Let's create an invalid stream name.
        final String id = "@-"+ _uuid;

        // Let's put that bad boy as app/octet-stream.
        final InputStream fauxFile = IOUtils.toInputStream(_testPayload);
        final Response response = _client.path(String.format("/%s", id)).request().put(Entity.entity(fauxFile, MediaType.APPLICATION_OCTET_STREAM_TYPE));

        // An invalid character in the stream ID should return a 403/FORBIDDEN.
        Assert.assertThat(403, is(equalTo(response.getStatus())));
    }

    /**
     * Tests a round trip of {@link StreamResource#createStream(UriInfo, String, List, InputStream)},
     * {@link StreamResource#getStreamById(String, List)} for a binary object, in this case, an image.
     */
    @Test
    public void testBinaryRoundTrip() throws Exception
    {
        // Grab an MD5 of the original file;
        final String imageMD5 = DigestUtils.md5Hex(getClass().getResourceAsStream("/8x8_Logo.png"));

        // We should get a 404, since the file is not there yet.
        final Response response = _client.path(_uuid).request("application/octet-stream").get();
        Assert.assertThat(404, is(equalTo(response.getStatus())));

        // Let's create the stream.
        final Response creationResponse = _client.path(String.format("/%s", _uuid))
                                                 .request()
                                                 .post(Entity.entity(getClass().getResourceAsStream("/8x8_Logo.png"),
                                                       MediaType.APPLICATION_OCTET_STREAM_TYPE));

        // We should get back a 201/CREATED with a Location header to /(uuid).
        final String location = creationResponse.getLocation().toASCIIString();
        Assert.assertThat(201, is(equalTo(creationResponse.getStatus())));
        Assert.assertThat(URL_PREFIX + "/" + _uuid, is(equalTo(location)));

        // And if we hit that resource, we should get our file back.
        final WebTarget newClient = ClientBuilder.newClient().target(location);
        final Response getResponse = newClient.request("application/octet-stream").get();

        // We should get a 200/OK our image back. We'll verify by checking the MD5.
        Assert.assertThat(200, is(equalTo(getResponse.getStatus())));
        Assert.assertThat(DigestUtils.md5Hex(getResponse.readEntity(InputStream.class)), is(equalTo(imageMD5)));

        // Clean up after ourselves. Hopefully.
        FileUtils.deleteQuietly( new File(_storageDirectory, _uuid));
    }

    /**
     * Tests a round trip where our filters match, and we expect the happy path.
     */
    @Test
    public void testRoundTripWithFilters() throws Exception
    {
        // Verify nothing is on the filesystem with that ID.
        final File file = new File(_storageDirectory, _uuid);
        Assert.assertThat(false, is(equalTo(file.exists())));

        // Let's post that bad boy as app/octet-stream.
        final InputStream fauxFile = IOUtils.toInputStream(_testPayload);
        final Response response = _client.path(String.format("/%s", _uuid))
                .queryParam("filters", "zip", "encrypt", "base64")
                .request()
                .post(Entity.entity(fauxFile, MediaType.APPLICATION_OCTET_STREAM_TYPE));

        // We should get back a 201/CREATED with a Location header to /(uuid).
        final String location = response.getLocation().toASCIIString();
        Assert.assertThat(201, is(equalTo(response.getStatus())));
        Assert.assertThat(URL_PREFIX + "/" + _uuid, is(equalTo(location)));

        // And if we hit that resource, we should get our file back.
        final WebTarget newClient = ClientBuilder.newClient().target(location);

        final Response getResponse = newClient.queryParam("filters", "zip", "encrypt", "base64")
                .request("application/octet-stream")
                .get();

        // We should get a 200/OK with what we wrote to the filesystem earlier.
        Assert.assertThat(200, is(equalTo(getResponse.getStatus())));
        Assert.assertThat(getResponse.readEntity(String.class), is(equalTo(_testPayload)));

        // Make sure we've actually done something with our filters...
        Assert.assertThat(FileUtils.readFileToString(file), is(not(equalTo(_testPayload))));

        // Clean up after ourselves. Hopefully.
        FileUtils.deleteQuietly(file);
    }

    // TODO [kog@epiphanic.org - 6/2/15]: Should probably come in with an ExceptionMapper here.

    /**
     * Tests a round trip where our input and output filters don't match. The outbound filters are going to fail since
     * we're going to try and unzip and decrypt something we can't. We'll get back a 500/INTERNAL SERVER ERROR here.
     */
    @Test
    public void testRoundTripWithMisMatchedFilters() throws Exception
    {
        // Verify nothing is on the filesystem with that ID.
        final File file = new File(_storageDirectory, _uuid);
        Assert.assertThat(false, is(equalTo(file.exists())));

        // Let's post that bad boy as app/octet-stream.
        final InputStream fauxFile = IOUtils.toInputStream(_testPayload);
        final Response response = _client.path(String.format("/%s", _uuid))
                .queryParam("filters", "base64")
                .request()
                .post(Entity.entity(fauxFile, MediaType.APPLICATION_OCTET_STREAM_TYPE));

        // We should get back a 201/CREATED with a Location header to /(uuid).
        final String location = response.getLocation().toASCIIString();
        Assert.assertThat(201, is(equalTo(response.getStatus())));
        Assert.assertThat(URL_PREFIX + "/" + _uuid, is(equalTo(location)));

        // And if we hit that resource, we should get our file back.
        final WebTarget newClient = ClientBuilder.newClient().target(location);

        final Response getResponse = newClient.queryParam("filters", "zip", "encrypt", "base64")
                                              .request("application/octet-stream")
                                              .get();

        // We should get a 200/OK with, but it won't match.
        Assert.assertThat(500, is(equalTo(getResponse.getStatus())));

        // Demonstrate that all we've done is Base64 encoded our value.
        Assert.assertThat(FileUtils.readFileToString(file).trim(), is((equalTo(Base64.encodeAsString(_testPayload)))));

        // Clean up after ourselves. Hopefully.
        FileUtils.deleteQuietly(file);
    }

    /**
     * Tests a round trip where we've asked for filters that don't exist. This should be the same as a regular round
     * trip.
     */
    @Test
    public void testRoundTripWithUnknownFilters() throws Exception
    {
        // Verify nothing is on the filesystem with that ID.
        final File file = new File(_storageDirectory, _uuid);
        Assert.assertThat(false, is(equalTo(file.exists())));

        // Let's post that bad boy as app/octet-stream.
        final InputStream fauxFile = IOUtils.toInputStream(_testPayload);
        final Response response = _client.path(String.format("/%s", _uuid))
                                         .queryParam("filters", "taters", "nottaters")
                                         .request()
                                         .post(Entity.entity(fauxFile, MediaType.APPLICATION_OCTET_STREAM_TYPE));

        // We should get back a 201/CREATED with a Location header to /(uuid).
        final String location = response.getLocation().toASCIIString();
        Assert.assertThat(201, is(equalTo(response.getStatus())));
        Assert.assertThat(URL_PREFIX + "/" + _uuid, is(equalTo(location)));

        // And if we hit that resource, we should get our file back.
        final WebTarget newClient = ClientBuilder.newClient().target(location);

        final Response getResponse = newClient.queryParam("filters", "taters", "nottaters")
                                              .request("application/octet-stream")
                                              .get();

        // We should get a 200/OK with what we wrote to the filesystem earlier.
        Assert.assertThat(200, is(equalTo(getResponse.getStatus())));
        Assert.assertThat(getResponse.readEntity(String.class), is(equalTo(_testPayload)));

        // And then demonstrate the file has had nothing done to it.
        Assert.assertThat(FileUtils.readFileToString(file), is(equalTo(_testPayload)));

        // Clean up after ourselves. Hopefully.
        FileUtils.deleteQuietly(file);
    }
}
